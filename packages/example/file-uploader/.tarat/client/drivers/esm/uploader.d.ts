// Generated by dts-bundle-generator v8.0.1

import EventEmitter from 'eventemitter3';
import { Draft } from 'immer';

export type TContextData = string;
export interface IHookContext {
	initialArgList: any;
	data: Array<[
		TContextData,
		Promise<any>,
		number
	] | [
		TContextData,
		null
	] | [
		TContextData
	] | [
		TContextData,
		any,
		number
	]>;
	name: string;
	index?: number;
	indexName?: string;
	args?: any[];
}
export type THookDepUnit = [
	"h" | "ic",
	number,
	(number | [
		"c",
		number,
		string
	])[],
	(number | [
		"c",
		number,
		string
	])[]?
];
export type THookDeps = Array<THookDepUnit>;
export interface IDataPatch {
	op: "replace" | "add" | "remove";
	path: (string | number)[];
	value?: any;
}
export type TPath = (string | number)[];
export type THookNames = [
	number,
	string
][];
export interface Driver extends Function {
	(...prop: any): any;
	__deps__?: THookDeps;
	__names__?: THookNames;
	__name__?: string;
	__namespace__?: string;
}
export interface ITarget<T> {
	watcher: Watcher<T>;
	notify: (hook?: ISource<T>, patches?: IDataPatch[], rc?: ReactiveChain) => void;
	addDep: (source: ISource<T>, path?: (number | string)[]) => void;
}
export interface ISource<U> {
	watchers: Set<Watcher<U>>;
	addWatcher: (w: Watcher<U>) => void;
}
declare class Watcher<T = Hook> {
	target: ITarget<ISource<T>>;
	deps: Map<ISource<T>, (string | number)[][]>;
	constructor(target: ITarget<ISource<T>>);
	notify(dep: ISource<T>, path: TPath, patches?: IDataPatch[], reactiveChain?: ReactiveChain): boolean;
	addDep(dep: ISource<T>, path?: (number | string)[]): () => void;
}
declare class Hook extends EventEmitter {
	/** hook's name for debugging */
	name?: string;
	freezed?: boolean;
	watchers: Set<Watcher<this>>;
	addWatcher(w: Watcher<Hook>): void;
}
declare class State<T = any> extends Hook {
	_internalValue: T;
	freezed?: boolean;
	modifiedTimestamp: number;
	inputComputePatchesMap: Map<InputCompute, [
		T,
		IDataPatch[]
	]>;
	contextName: string;
	needContextValue: boolean;
	needCheckAndRefresh: boolean;
	applyComputeAsync: boolean;
	constructor(data: T);
	trigger(path?: (number | string)[], patches?: IDataPatch[], reactiveChain?: ReactiveChain<T>, triggeredSet?: Set<Watcher>): Set<Watcher<Hook>>;
	hasPatches(ic: InputCompute): boolean;
	get value(): T;
	update(v: T, patches?: IDataPatch[], silent?: boolean, reactiveChain?: ReactiveChain<T>): void;
	applyComputePatches(ic: InputCompute, reactiveChain?: ReactiveChain<T>): void;
	getInputComputeDraftValue(): T;
	addComputePatches(value: T, patches: IDataPatch[]): void;
	checkAndRefresh(): void;
}
export interface AsyncHook<T> {
	init: boolean;
	getterPromise: Promise<T> | null;
	startAsyncGetter: () => {
		end: () => void;
		valid: () => boolean;
	};
	pending: boolean;
}
declare class AsyncState<T> extends State<T> implements AsyncHook<T> {
	init: boolean;
	getterPromise: Promise<T> | null;
	asyncCount: number;
	startAsyncGetter(): {
		end: () => void;
		valid: () => boolean;
	};
	get pending(): boolean;
}
declare function underComputed(): boolean;
export type FComputedFuncGenerator<T> = (prev?: T) => Generator<any, T, unknown>;
export type FComputedFuncAsync<T> = (prev?: T) => T;
export type FComputedFunc<T> = (prev?: T) => T;
declare class Computed<T> extends AsyncState<T | Symbol> implements ITarget<T> {
	getter: FComputedFunc<T | Symbol> | FComputedFuncAsync<T | Symbol> | FComputedFuncGenerator<T | Symbol>;
	batchRunCancel: () => void;
	watcher: Watcher<State<any>>;
	static underComputed: typeof underComputed;
	constructor(getter: FComputedFunc<T | Symbol> | FComputedFuncAsync<T | Symbol> | FComputedFuncGenerator<T | Symbol>);
	get value(): T | Symbol;
	run(innerReactiveChain?: ReactiveChain): void;
	tryModify(reactiveChain?: ReactiveChain): void;
	notify(h?: ISource<T>, p?: IDataPatch[], reactiveChain?: ReactiveChain): void;
	addDep(source: ISource<T>, path: (string | number)[]): void;
}
export type InputComputeFn<T extends any[]> = (...arg: T) => void;
export type AsyncInputComputeFn<T extends any[]> = (...arg: T) => Promise<void>;
export type GeneratorInputComputeFn<T extends any[]> = (...arg: T) => Generator<unknown, void, T>;
declare class InputCompute<P extends any[] = any> extends Hook {
	getter: InputComputeFn<P> | AsyncInputComputeFn<P> | GeneratorInputComputeFn<P>;
	/** @TODO should not couple the "scope" */
	scope: CurrentRunnerScope;
	commitPromise: Promise<void> | null;
	constructor(getter: InputComputeFn<P> | AsyncInputComputeFn<P> | GeneratorInputComputeFn<P>, 
	/** @TODO should not couple the "scope" */
	scope: CurrentRunnerScope);
	inputFuncStart(): void;
	commitComputePatches(reactiveChain?: ReactiveChain): (void | Promise<void>)[] | undefined;
	inputFuncEnd(reactiveChain?: ReactiveChain): Promise<void>;
	run(...args: any): Promise<void>;
}
declare class RunnerContext<T extends Driver> {
	driverName: string;
	args?: Parameters<T>;
	initialArgList: Parameters<T>;
	initialData: IHookContext["data"] | null;
	triggerHookIndex?: number;
	triggerHookName?: string;
	withInitialContext: boolean;
	scope: CurrentRunnerScope;
	constructor(driverName: string, args?: Parameters<T>, initialContext?: IHookContext);
	bindScope(scope: CurrentRunnerScope): void;
	serialize(type: "current" | "next"): void;
	formatContextData(hooks: Hook[], enable?: (i: number) => boolean): ([
		string,
		Promise<any>,
		number
	] | [
		string,
		null
	] | [
		string
	] | [
		string,
		any,
		number
	])[];
	/**
	 * need deliver context principles, sort by priority:
	 * 1.model/cache(server) needn't
	 * 2.state
	 * 3.related set/get
	 */
	serializeAction(hooks: Hook[], hookIndex: number, args: any[], deps: Set<number>): IHookContext;
	serializePatch(hooks: Hook[]): IHookContext;
	serializeBase(hooks: Hook[]): IHookContext;
	apply(hooks: Hook[], c: IHookContext, needUpdateCallback: (h: State, value: any, timestamp: number) => void): void;
}
export interface IRunnerOptions {
	beleiveContext: boolean;
	updateCallbackSync?: boolean;
	applyComputeParallel?: boolean;
	runnerContext?: Symbol;
}
declare enum EScopeState {
	init = "init",
	idle = "idle",
	pending = "pending"
}
declare class CurrentRunnerScope<T extends Driver = any> extends EventEmitter {
	runnerContext: RunnerContext<T>;
	intialContextDeps: THookDeps;
	intialContextNames: THookNames;
	name?: string;
	hooks: (Hook | undefined)[];
	composes: Record<string, any>[];
	stateChangeCallbackRunning: boolean;
	stateChangeCallbackCancel: () => void;
	stateChangeWaitHooks: Set<Hook>;
	watcher: Watcher<Hook>;
	initialHooksSet?: Set<number>;
	reactiveChainStack: ReactiveChain[];
	/**
	 * receive by runner options
	 */
	beleiveContext: boolean;
	updateCallbackSync: boolean;
	applyComputeParallel: boolean;
	effectFuncArr: Function[];
	disposeFuncArr: Function[];
	static events: {
		enterComposeDriver: string;
		leaveComposeDriver: string;
		update: string;
		effect: string;
	};
	static getCurrent: () => CurrentRunnerScope<Driver>;
	constructor(runnerContext: RunnerContext<T>, intialContextDeps: THookDeps, intialContextNames: THookNames);
	/**
	 * copy context value into scope for updateXXX hook
	 */
	initializeHookSet(): void;
	triggerEnterComposeDriver(driverNamespace: string, dirverName: string): () => void;
	setOptions(op: Partial<IRunnerOptions>): void;
	effect(f: Function): void;
	flushEffects(): void;
	appendDispose(f: Function): void;
	dispose(): void;
	/**
	 * call the executable hook: Model, InputCompute
	 * @TODO the executable hook maybe need a abstract base class
	 */
	callHook(hookIndex: number, args: any[]): Promise<void>;
	/**
	 * while enter UI will activate this function
	 */
	activate(): void;
	deactivate(): void;
	private notifyAllState;
	onUpdate(fn: (...args: any[]) => void): () => void;
	notifyOuter(): void;
	notify(s?: Hook): void;
	addDep(source: ISource<T>, path: (string | number)[]): void;
	addHook(v: Hook | undefined): void;
	applyDepsMap(): void;
	/**
	 * offset compose names and current initial names
	 */
	appendComposeNames(si: number, names?: THookNames): void;
	offsetComposeIndex(originalIndex: number, newLength: number, icrement: number): void;
	/**
	 * add compose deps to current driver.
	 * plus current hook dep index
	 */
	appendComposeDeps(si: number, ei: number, currentComposeLengh: number, deps?: THookDeps): void;
	applyAllComputePatches(currentInputCompute: InputCompute, reactiveChain?: ReactiveChain): (void | Promise<void>)[];
	applyContextFromServer(c: IHookContext): void;
	getState(): EScopeState.idle | EScopeState.pending;
	ready(specifies?: Set<number>): Promise<void>;
}
/**
 * collect reactive chain for debug
 */
export type ChainTrigger<T> = CurrentRunnerScope<any> | State<T> | InputCompute<any>;
declare class ReactiveChain<T = any> {
	parent?: ReactiveChain;
	hook?: ChainTrigger<T>;
	isRoot: boolean;
	allLeafCount: number;
	order: number;
	name?: string;
	hookIndex?: number;
	hookKey?: string;
	oldValue: T | undefined;
	newValue: T | undefined;
	hasNewValue: boolean;
	children: ReactiveChain<T>[];
	type?: "update" | "notify" | "call";
	static getCurrent: () => ReactiveChain<any>;
	constructor(parent?: ReactiveChain, hook?: ChainTrigger<T>);
	static withChain<T extends (...args: any[]) => any>(chain: ReactiveChain, fn: T): ReturnType<T>;
	plusLeaf(): any;
	stop(): void;
	update(): void;
	add(trigger: ChainTrigger<T>, key?: string): ReactiveChain<T>;
	addCall(trigger: ChainTrigger<T>, key?: string): ReactiveChain<T>;
	addNotify(trigger: ChainTrigger<T>): ReactiveChain<T>;
	addUpdate(child: ChainTrigger<T>): ReactiveChain<T>;
	print(): void;
}
export type IModifyFunction<T> = ((draft: Draft<T>) => void) | T;
export interface IModelHookContext extends IHookContext {
	patch?: [
		string,
		IModelPatchRecord[]
	][];
}
export type IPatch = IDataPatch | IModelPatch<any>;
export type IModelCreateData<T> = Omit<IModelData<T>, "where"> | Omit<IModelData<T>, "where">[];
export interface IModelData<T> {
	where: {
		id: number;
	} & Partial<T>;
	data: {
		[k in keyof T]?: T[k] | {
			connect?: Partial<T[k]>;
			create?: Partial<T[k]>;
		};
	};
	include?: Record<string, boolean>;
}
export type IModelPatchCreate<T> = {
	op: "create";
	value: IModelCreateData<T>;
};
export type IModelPatchUpdate<T> = {
	op: "update";
	value: IModelData<T>;
};
export type IModelPatchRemove<T> = {
	op: "remove";
	value: Omit<IModelData<T>, "data">;
};
export type IModelPatch<T> = IModelPatchCreate<T> | IModelPatchUpdate<T> | IModelPatchRemove<T>;
export interface IModelOption {
	immediate?: boolean;
	unique?: boolean;
	autoRollback?: boolean;
	pessimisticUpdate?: boolean;
	ignoreClientEnable?: boolean;
	checkRefresh?: (ps: IPatch[]) => boolean;
}
export interface IQuerySelect {
	[k: string]: boolean | {
		select: IQuerySelect;
	};
}
export interface IQueryInclude {
	[k: string]: boolean | {
		include: IQueryInclude;
	};
}
export interface IQueryWhere {
	where?: {
		[k: string]: any;
	};
	skip?: number;
	take?: number;
	include?: IQueryInclude;
	select?: IQuerySelect;
	orderBy?: {
		[k: string]: "desc" | "asc";
	};
	cursor?: {
		id?: number;
	};
}
export interface IModelQuery {
	entity: string;
	query: IQueryWhere;
}
export interface IModelIndexesBase {
	[k: string]: string | IModelIndexesBase;
}
export interface IModelPatchRecord {
	timing: number;
	patch: IModelPatch<any>[];
}
declare class ModelEvent {
	private data;
	listeners: Function[];
	subscribe(f: () => void): () => void;
	from(arr: IModelHookContext["patch"]): void;
	toArray(): [
		string,
		IModelPatchRecord[]
	][];
	getRecord(m: {
		entity: string;
	}): IModelPatchRecord[];
	pushPatch(m: {
		entity: string;
	}, p: IModelPatch<any>[]): void;
}
declare class RunnerModelScope<T extends Driver = any> extends CurrentRunnerScope<T> {
	runnerContext: RunnerContext<T>;
	initialContextDeps: THookDeps;
	initialContextNames: THookNames;
	modelIndexes: IModelIndexesBase | undefined;
	modelIndexesPath: string[];
	modelPatchEvents: ModelEvent;
	modelHookFactory: {
		model: typeof mountPrisma;
		prisma: typeof mountPrisma;
		writePrisma: typeof mountWritePrisma;
		writeModel: typeof writeModel;
		createPrisma: typeof mountCreatePrisma;
		updatePrisma: typeof mountUpdatePrisma;
		removePrisma: typeof mountRemovePrisma;
		computedInServer: typeof mountComputedInServer;
		inputComputeInServer: typeof mountInputComputeInServer;
	};
	constructor(runnerContext: RunnerContext<T>, initialContextDeps: THookDeps, initialContextNames: THookNames);
	readyRelated(h: Hook): Promise<void>;
	private notifyAllModel;
	getRealEntityName(entityKey: string): string;
	applyContextFromServer(c: IModelHookContext): void;
	triggerEnterComposeDriver(driverNamespace: string, driverName: string): () => void;
	hookNumberIndexDeps(): THookDeps;
	/**
	 * get all related hook index according to passive hookIndex
	 * design logic:
	 * 1.getD -> getD -> getD
	 * 2.setD in who's getD -> getD
	 */
	getRelatedHookIndexes(hookIndex: number): Set<number>;
	getShallowRelatedHookIndexes(hookIndex: number): Set<number>;
	getDependenceByModel(indexes: Set<number>): Set<number>;
	createBaseContext(): IHookContext;
	getRelatedIndexesByHook(h: Hook, excludeSelf?: boolean): Set<number>;
	/**
	 * as a response while receive a input context
	 */
	createPatchContext(): IModelHookContext;
	/**
	 * as a input of other's Runner and trigger
	 * need deliver context principles, sort by priority:
	 * 1.model/cache(server) needn't
	 * 2.state
	 * 3.related set/get
	 */
	createActionContext(h?: Hook, args?: any[]): IHookContext;
	createShallowActionContext(h?: Hook, args?: any[]): IHookContext;
	createInputComputeContext(h?: Hook, args?: any[]): IHookContext;
}
declare abstract class Model<T extends any[]> extends AsyncState<T> {
	options: IModelOption;
	scope: RunnerModelScope;
	queryWhereComputed: Computed<IModelQuery["query"] | void> | null;
	watcher: Watcher;
	entity: string;
	findGetters: Array<() => IModelQuery["query"] | undefined>;
	constructor(entity: string, getter: (() => IModelQuery["query"] | undefined) | undefined, options: IModelOption, scope: RunnerModelScope);
	injectFindGetter(fn: () => IModelQuery["query"] | undefined): void;
	setGetter(fn: () => IModelQuery["query"] | undefined): void;
	addDep(source: ISource<T>, path?: (string | number)[]): void;
	notify(h?: Hook, p?: IPatch[], reactiveChain?: ReactiveChain): void;
	getQueryWhere(reactiveChain?: ReactiveChain): Promise<IModelQuery["query"] | void>;
	get value(): T;
	ready(): Promise<void>;
	query(reactiveChain?: ReactiveChain): void;
	enableQuery(): Promise<boolean>;
	abstract executeQuery(reactiveChain?: ReactiveChain): Promise<void>;
	abstract exist(obj: Partial<T[0]>): Promise<T | undefined>;
	abstract refresh(): Promise<void>;
	abstract checkAndRefresh(): Promise<void>;
	applyComputePatches(ic: InputCompute, reactiveChain?: ReactiveChain): Promise<void>;
	abstract updateWithPatches(v: T, patches: IDataPatch[], silent: boolean, reactiveChain?: ReactiveChain): Promise<void>;
}
export type TWriteMethod = "create" | "update" | "remove" | "find";
declare abstract class WriteModel<T extends any[]> extends AsyncState<T | Symbol> {
	sourceModelGetter: {
		_hook: Model<T>;
	} | string;
	basicGetData: (() => Partial<T[0]>) | undefined;
	protected scope: RunnerModelScope;
	abstract identifier: string;
	entity: string;
	sourceModel?: Model<T>;
	extraGetters: Record<TWriteMethod, Array<() => Partial<T[0]>>>;
	inputComputeModelPatchesMap: Map<InputCompute, [
		T[0],
		IModelPatch<T[0]>[]
	]>;
	constructor(sourceModelGetter: {
		_hook: Model<T>;
	} | string, basicGetData: (() => Partial<T[0]>) | undefined, scope: RunnerModelScope);
	hasPatches(ic: InputCompute): boolean;
	refresh(): Promise<void>;
	injectGetter(fn: () => Partial<T[0]>, method: TWriteMethod): void;
	getData(method: TWriteMethod): T[0];
	setGetter(fn: () => Partial<T[0]>): void;
	abstract createRow(obj?: Partial<T[0]>): Promise<void>;
	abstract updateRow(where: number, obj?: {
		[k: string]: any;
	}): Promise<void>;
	abstract removeRow(where: number): Promise<void>;
	abstract executeModelPath(ps: IModelPatch<T[0]>[]): Promise<void>;
	addModelPatches(value: T[0], patches: IModelPatch<T[0]>[]): void;
	applyComputePatches(ic: InputCompute, reactiveChain?: ReactiveChain): Promise<void>;
}
declare class Prisma<T extends any[]> extends Model<T> {
	identifier: string;
	executeQuery(reactiveChain?: ReactiveChain): Promise<void>;
	exist(obj: Partial<T[0]>): Promise<T>;
	refresh(): Promise<void>;
	updateWithPatches(v: T, patches: IDataPatch[], silent: boolean, reactiveChain?: ReactiveChain): Promise<void>;
	checkAndRefresh(): Promise<void>;
}
declare class WritePrisma<T extends any[]> extends WriteModel<T> {
	identifier: string;
	executeModelPath(ps: IModelPatch<T[0]>[]): Promise<void>;
	createRow(obj?: IModelData<T[0]>["data"], include?: {
		[k in keyof T[0]]: boolean;
	}): Promise<void>;
	updateRow(where: number, obj?: IModelData<T[0]>["data"]): Promise<void>;
	removeRow(where?: number): Promise<void>;
}
export interface AsyncHook<T> {
	init: boolean;
	getterPromise: Promise<T> | null;
	startAsyncGetter: () => {
		end: () => void;
		valid: () => boolean;
	};
	pending: boolean;
}
declare class AsyncInputCompute<T extends any[]> extends InputCompute<T> implements AsyncHook<T> {
	getter: InputComputeFn<T> | AsyncInputComputeFn<T> | GeneratorInputComputeFn<T>;
	scope: RunnerModelScope;
	init: boolean;
	getterPromise: Promise<T> | null;
	asyncCount: number;
	constructor(getter: InputComputeFn<T> | AsyncInputComputeFn<T> | GeneratorInputComputeFn<T>, scope: RunnerModelScope);
	startAsyncGetter(): {
		end: () => void;
		valid: () => boolean;
	};
	get pending(): boolean;
}
declare class InputComputeInServer<P extends any[]> extends AsyncInputCompute<P> {
	run(...args: any[]): Promise<void>;
}
declare function mountInputComputeInServer(func: any): {
	(...args: any): Promise<void>;
	_hook: InputComputeInServer<any[]>;
};
declare function mountComputedInServer<T>(fn: FComputedFuncGenerator<T>): (() => T) & {
	_hook: Computed<T>;
};
declare function mountComputedInServer<T>(fn: FComputedFuncAsync<T>): (() => T) & {
	_hook: Computed<T>;
};
declare function mountComputedInServer<T>(fn: FComputedFunc<T>): (() => T) & {
	_hook: Computed<T>;
};
declare function mountPrisma<T extends any[]>(e: string, q?: () => IModelQuery["query"] | undefined, op?: IModelOption): {
	(): T;
	(parameter: IModifyFunction<T>): [
		T,
		IDataPatch[]
	];
} & {
	_hook: Prisma<T>;
	exist: (obj: Partial<T[0]>) => Promise<T>;
	refresh: () => Promise<void>;
};
declare function mountWritePrisma<T extends any[]>(source: {
	_hook: Model<T>;
}, q: () => Partial<T[0]>): (() => never) & {
	_hook: WritePrisma<T>;
	create: (obj?: T[0] extends infer T_1 ? {
		[k in keyof T_1]?: T[0][k] | {
			connect?: Partial<T[0][k]>;
			create?: Partial<T[0][k]>;
		};
	} : never, include?: T[0] extends infer T_2 ? {
		[k_1 in keyof T_2]: boolean;
	} : never) => Promise<void>;
	update: (where: number, obj?: T[0] extends infer T_1 ? {
		[k in keyof T_1]?: T[0][k] | {
			connect?: Partial<T[0][k]>;
			create?: Partial<T[0][k]>;
		};
	} : never) => Promise<void>;
	remove: (where?: number) => Promise<void>;
};
declare function mountCreatePrisma<T extends any[]>(source: {
	_hook: Model<T>;
}, q: () => Partial<T[0]>): ((receivedData?: Partial<T[0]>) => Promise<void>) & {
	_method: string;
	_hook: WritePrisma<T>;
};
declare function mountUpdatePrisma<T extends any[]>(source: {
	_hook: Model<T>;
}, q: () => Partial<T[0]>): ((where: number, receivedData?: Partial<T[0]>) => Promise<void>) & {
	_method: string;
	_hook: WritePrisma<T>;
};
declare function mountRemovePrisma<T extends any[]>(source: {
	_hook: Model<T>;
}, q: () => Partial<T[0]>): ((where?: number) => Promise<void>) & {
	_method: string;
	_hook: WritePrisma<T>;
};
declare function writeModel<T extends any[]>(source: {
	_hook: Model<T>;
}, q: () => Partial<T[0]>): (() => never) & {
	_hook: WritePrisma<T>;
	create: (obj?: T[0] extends infer T_1 ? {
		[k in keyof T_1]?: T[0][k] | {
			connect?: Partial<T[0][k]>;
			create?: Partial<T[0][k]>;
		};
	} : never, include?: T[0] extends infer T_2 ? {
		[k_1 in keyof T_2]: boolean;
	} : never) => Promise<void>;
	update: (where: number, obj?: T[0] extends infer T_1 ? {
		[k in keyof T_1]?: T[0][k] | {
			connect?: Partial<T[0][k]>;
			create?: Partial<T[0][k]>;
		};
	} : never) => Promise<void>;
	remove: (where?: number) => Promise<void>;
};
export default function uploader<T>(): {
	writeFileStroage: (() => never) & {
		_hook: WritePrisma<{
			name: string;
			link: string;
		}[]>;
		create: (obj?: {
			name?: string | {
				connect?: string;
				create?: string;
			};
			link?: string | {
				connect?: string;
				create?: string;
			};
		}, include?: {
			name: boolean;
			link: boolean;
		}) => Promise<void>;
		update: (where: number, obj?: {
			name?: string | {
				connect?: string;
				create?: string;
			};
			link?: string | {
				connect?: string;
				create?: string;
			};
		}) => Promise<void>;
		remove: (where?: number) => Promise<void>;
	};
	updateStorage: AsyncInputComputeFn<any[]> & {
		_hook: Hook;
	};
	createStorage: AsyncInputComputeFn<any[]> & {
		_hook: Hook;
	};
	inputFile: {
		(): {
			name: string;
			filepath?: string;
			newFilename?: string;
			originalFilename?: string;
			_writeStream: WritableStream;
		};
		(parameter: IModifyFunction<{
			name: string;
			filepath?: string;
			newFilename?: string;
			originalFilename?: string;
			_writeStream: WritableStream;
		}>): [
			{
				name: string;
				filepath?: string;
				newFilename?: string;
				originalFilename?: string;
				_writeStream: WritableStream;
			},
			IDataPatch[]
		];
	} & {
		_hook: State<{
			name: string;
			filepath?: string;
			newFilename?: string;
			originalFilename?: string;
			_writeStream: WritableStream;
		}>;
	};
	OSSLink: (() => {
		name: string;
		link: string;
	}) & {
		_hook: Computed<{
			name: string;
			link: string;
		}>;
	};
};

export {};
