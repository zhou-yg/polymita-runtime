import { IConfig } from "../config";
import * as fs from 'fs'
import * as path from 'path'
import { equalFileContent, loadJSON, logFrame, traverseFirstDir, tryMkdir } from "../util";
import * as prismaInternals from '@prisma/internals'
import os from 'os'
import { cp } from "shelljs";
import { camelCase } from 'camel-case'
import { autoGeneratedTip } from "./constants";
import { upperFirst } from "lodash";
import { initBlankSchemaPart } from "./prebuild";

interface IEnhancement {
  extraRelation: {
    from: {
      model: string
      field: string
    },
    type: '1:1' | '1:n' | 'n:1' | 'n:n'
    to: {
      model: string
      field: string
    }
  }[]
  modelAddition: {
    name: string,
    fields: {
      name: string
      type: string
      extra: string
    }[]
  }[]
}

interface IPrismaFile {
  moduleName?: string;
  path: string;
  content: string
}

export function findDependentPrisma (c: IConfig) {
  const schemaFiles: Array<IPrismaFile> = []

  c.allDependencyModules.forEach(({ dir, name: moduleName }) => {
    logFrame('prisma moduleName: ', moduleName);

    const depSchemaPath = path.join(dir, c.buildDirectory, c.modelsDirectory, 'schema.prisma')
    const r2 = fs.existsSync(depSchemaPath)

    if (r2) {
      schemaFiles.push({
        moduleName,
        path: depSchemaPath,
        content: fs.readFileSync(depSchemaPath).toString()
      })
    }
  })

  return schemaFiles
}

interface IParsedSchemaStruct {
  name: string
  fieldLines: string[]
}

function pickExpectModel (schemaContents: IPrismaFile[]) {
  const contents = schemaContents.map(({content}) => {
    return content.replace(/model \w+ {[\w\W\n]*?}/g, '')
  })

  return contents
}

function lowerFirst (str: string) {
  return str ? str[0].toLowerCase() + str.substring(1) : str
}

function getSourceReferrenceType (source: IParsedSchemaStruct, targetProp: string) {
  let type = ''
  source.fieldLines.forEach(line => {
    const row = line.split(' ').filter(Boolean).map(s => s.trim())
    
    if (!type && row[0] === targetProp) {
      type = row[1]
    }
  })

  if (!type) {
    throw new Error(`[getSourceReferrenceType] can not find ${targetProp} in source(name=${source.name})`)
  }

  return type
}

/**
 * some npm module name start with "@", which is not valid for prisma model name
 */
export function transformModelName(str: string) {
  return str.replace(/^@/, '').replace(/\/|@|-/g, '_')
}

async function generateNewSchema (c: IConfig, schemaContentArr: IPrismaFile[], enhanceJSON?: IEnhancement) {
  const schemaStructArr = await Promise.all(schemaContentArr.map(async prismaFile => {
    const { moduleName, content: schemaContent } = prismaFile

    const model = await prismaInternals.getDMMF({
      datamodel: schemaContent
    })
    const models = model.datamodel.models
    
    const modelsStruct = models.map((n: any) => {
      const { name } = n
      const r = schemaContent.match(new RegExp(`model ${name} {[\\w\\W\\n]*?}`, 'g'))
      const nameWithModulePrefix = moduleName ? upperFirst(transformModelName(`${moduleName}_${name}`)) : name
      const fieldLines = r?.[0]?.split('\n').slice(1, -1) || []

      const newFieldLines = fieldLines.map(line => {
        const [columnName, columnType, ...rest] = line.trim().split(/\s+/)
        if (columnType) {
          // pick model type that having the highest match rate
          const [selfCustomModel] = models.filter(m => new RegExp(`^${m.name}`).test(columnType)).sort((p, n) => p.name.length - n.name.length)
          if (selfCustomModel) {
            const columnTypePostfix = columnType.replace(new RegExp(`^${selfCustomModel.name}`), '')
            const newColumnType = `${moduleName ? upperFirst(transformModelName(`${moduleName}_${selfCustomModel.name}`)) : selfCustomModel.name}${columnTypePostfix}`
            return [
              columnName,
              newColumnType,
              ...rest
            ].join(' ')
          }
        }
        return line
      })

      return {
        name: nameWithModulePrefix,
        originalName: name,
        fieldLines: newFieldLines,
      }
    })
    
    return modelsStruct
  }))
  const schemaStructArrFlat:IParsedSchemaStruct[] = schemaStructArr.flat()

  const manyToManyCenteralModels: IParsedSchemaStruct[] = []

  if (enhanceJSON) {
    enhanceJSON.extraRelation?.forEach(relation => {
      const fromModel = transformModelName(relation.from.model)
      const toModel = transformModelName(relation.to.model)

      const source = schemaStructArrFlat.find(t => t.name === fromModel)
      const target = schemaStructArrFlat.find(t => t.name === toModel)

      if (!source || !target) {
        throw new Error(`[generateNewSchema] ${!!source} ${!!target} cannot found the source (name=${fromModel}) or target (name=${toModel}) `)
      }

      // prisma doc:https://www.prisma.io/docs/concepts/components/prisma-schema/relations/one-to-one-relations
      switch (relation.type) {
        case '1:1':
          {
            source.fieldLines.push(`${relation.from.field} ${target.name}?`)

            const type = getSourceReferrenceType(source, 'id')
            target.fieldLines.push(`${lowerFirst(source.name)} ${source.name} @relation(fields: [${relation.to.field}], references:[id])`)
            target.fieldLines.push(`${relation.to.field} ${type} @unique`)
          }
          break
        case '1:n':
          {
            source.fieldLines.push(`${relation.from.field} ${target.name}[]`)
            target.fieldLines.push(`${lowerFirst(source.name)} ${source.name} @relation(fields: [${relation.to.field}], references:[id])`)
            const type = getSourceReferrenceType(source, 'id')
            target.fieldLines.push(`${relation.to.field} ${type}`)
          }
          break
        case 'n:1':
          {
            const type = getSourceReferrenceType(source, 'id')
            source.fieldLines.push(`${lowerFirst(target.name)} ${target.name} @relation(fields: [${relation.from.field}], references:[id])`)
            source.fieldLines.push(`${relation.from.field} ${type}`)
            target.fieldLines.push(`${relation.to.field} ${source.name}[]`)
          }
          break
        case 'n:n':
          {
            const centeralModelName = `Many${source.name}ToMany${target.name}`
            const sourceReferType = getSourceReferrenceType(source, 'id')
            const targetReferType = getSourceReferrenceType(target, 'id')

            const m2mModel = {
              name: centeralModelName,
              fieldLines: [
                `${lowerFirst(source.name)} ${source.name} @relation(fields: [${relation.from.field}], references: [id])`,
                `${relation.from.field} ${sourceReferType}`,
                `${lowerFirst(target.name)} ${target.name} @relation(fields: [${relation.to.field}], references: [id])`,
                `${relation.to.field} ${targetReferType}`,
                `@@id([${relation.from.field}, ${relation.to.field}])`
              ]
            }
            manyToManyCenteralModels.push(m2mModel)

            source.fieldLines.push(`${relation.from.field} ${m2mModel.name}[]`)
            target.fieldLines.push(`${relation.to.field} ${m2mModel.name}[]`)
          }
          break
        default:
          const text = relation.type ? `[generateNewSchema] unexpected relation type "${relation.type}"` : `[generateNewSchema] must specific a relation type in [ 1:1, 1:n, n:1, n:n]`
          throw new Error(text)
      }
    })
  }

  const newSchemaContent = schemaStructArrFlat.concat(manyToManyCenteralModels).map(m => {
    return [
      `model ${m.name} {`,
      ...m.fieldLines,
      '}'
    ].join('\n')
  }).join('\n')

  return newSchemaContent
}

/**
 * read all exist partial schema, return all files content
 */
export function readExistingPrismaPart (c: IConfig) {
  const modelsDir = path.join(c.cwd, c.modelsDirectory)
  if (!fs.existsSync(modelsDir)) {
    return []
  }

  const existPrismaParts: IPrismaFile[] = []
  fs.readdirSync(modelsDir).forEach(file => {
    if (new RegExp(`${c.prismaModelPart}$`).test(file)) {
      const schema = fs.readFileSync(path.join(modelsDir, file)).toString()
      existPrismaParts.push({
        moduleName: '',
        path: path.join(modelsDir, file),
        content: schema
      })
    }
  })

  return existPrismaParts
}
export function readCurrentPrisma (c: IConfig): IPrismaFile {
  const file = path.join(c.cwd, c.modelsDirectory, c.targetSchemaPrisma)

  return {
    path: file,
    content: fs.existsSync(file) ? fs.readFileSync(file).toString() : ''
  }
}


async function generateSchemaFile (file: string, str: string[]) {
  const lines = autoGeneratedTip().concat(str).join('\n')

  const formatResult = await prismaInternals.formatSchema({ schema: lines })

  fs.writeFileSync(file, formatResult?.trimEnd() + os.EOL)
}

export async function composeSchema (c: IConfig) {
  const { modelDir, modelEnhance: enhanceFile, schemaPrisma: targetFile } = c.pointFiles.currentFiles.modelFiles
  
  let enhanceJSON: IEnhancement | undefined
  if (fs.existsSync(enhanceFile)) {
    enhanceJSON = loadJSON(enhanceFile)
  }
  if (c.model.engine === 'prisma') {
    const dependentPrismaFiles = findDependentPrisma(c)
    if (dependentPrismaFiles.length) {
      
      tryMkdir(modelDir)      
  
      const partSchema = path.join(c.cwd, c.modelsDirectory, `${c.prismaModelPart}`)
      if (!fs.existsSync(partSchema) && dependentPrismaFiles.length > 0) {
        cp(targetFile, partSchema)
      }

      if (
        dependentPrismaFiles.length &&
        readExistingPrismaPart(c).length === 0
      ) {
        initBlankSchemaPart(c)
      }
  
      const existPrismaPart = readExistingPrismaPart(c)
  
      if (existPrismaPart.length) {
        /**
         * if detect the dependent prisma, must backup orignal schema.prisma
         */
        const newSchemaContent = await generateNewSchema(
          c,
          existPrismaPart.concat(dependentPrismaFiles),
          enhanceJSON
        )
    
        const existPrismaPartWithoutModels = pickExpectModel(existPrismaPart)
        
        await generateSchemaFile(
          targetFile,
          [
            '// original writing schema',
            ...existPrismaPartWithoutModels,
            '// auto composing schema ',
            newSchemaContent,
          ]
        )
      }
    }
  }
}

interface IDependencyHook {
  name: string
  modulePath: string
}
const referrenceHookTemp = (arg: { path: string }) => `
${autoGeneratedTip().join('\n')}
import d from '${arg.path}'
Object.assign(d, { __polymita_compose__: true })
export { default } from '${arg.path}'
`
async function generateReferrenceDrivers (c: IConfig, h: IDependencyHook[]) {
  const curDriversDir = path.join(c.cwd, c.signalsDirectory, c.composeDriversDirectory)

  if (!fs.existsSync(curDriversDir) && h.length > 0) {
    fs.mkdirSync(curDriversDir, { recursive: true })
  }

  await Promise.all(h.map(obj => new Promise<void>((res, rej) => {
    const code = referrenceHookTemp({ path: obj.modulePath })
    const f = path.join(curDriversDir, `${obj.name}${c.ts ? '.ts' : '.js'}`)

    if (fs.existsSync(f)) {
      const existCode = fs.readFileSync(f).toString()
      if (equalFileContent(code, existCode)) {
        return res()
      }
    }
    
    fs.writeFile(f, code, (err) => {
      if (err) {
        rej(err)
      } else {
        res()
      }
    })
    // fs.writeFileSync(f, code)
  })))
}

export async function composeSignal(c: IConfig) {
  const dependencyDrivers: IDependencyHook[] = []
  
  c.allDependencyModules.forEach(({ dir, name: moduleName }) => {
    const distSignalsDir = path.join(dir, c.buildDirectory, c.signalsDirectory)
    if (!fs.existsSync(distSignalsDir)) {
      console.error(`[composeSignal] drivers not found in "${moduleName}/${c.buildDirectory}/${c.signalsDirectory}"`)
      return
    }

    fs.readdirSync(distSignalsDir)
      .filter(f => /\.js$/.test(f) && !/deps\.js$/.test(f))
      .forEach(f => {
        const { name } = path.parse(f)
        let driverName = name
        if (dependencyDrivers.find(v => v.name === driverName)) {
          driverName = camelCase(`${moduleName}.${name}`)
          if (dependencyDrivers.find(v => v.name === driverName)) {
            throw new Error('[polymita] can not handle hook name conflict between all dependency modules')
          }
        }
        dependencyDrivers.push({
          name: driverName,
          modulePath: `${moduleName}/${c.buildDirectory}/${c.signalsDirectory}/${name}`
        })
      })
  })
  await generateReferrenceDrivers(c, dependencyDrivers)
}

export function composeScripts (c: IConfig) {
  const destDir = path.join(c.cwd, c.scriptDirectory, c.composeDir)

  c.allDependencyModules.forEach(({ dir, name: moduleName }) => {
    const distScriptsDir = path.join(dir, c.buildDirectory, c.scriptDirectory)

    ;[c.serverDir, c.edgeDir].forEach(serverOrEdge => {
      const scriptDir = path.join(distScriptsDir, serverOrEdge)
      if (fs.existsSync(scriptDir)) {
        traverseFirstDir(scriptDir, f => {
          const modulePath = path.join(
            moduleName, c.buildDirectory, c.scriptDirectory, serverOrEdge,
            f.relativeFile,
          )
          const fileTemp = `export * from "${modulePath}"`
          
          const destFile = path.join(destDir, serverOrEdge, `${f.name}.ts`)
          const { dir } = path.parse(destFile)
          tryMkdir(dir)
          fs.writeFileSync(destFile, fileTemp)
        })
      }
    })
  })
}
